// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3932.subsystems;

import org.usfirst.frc3932.RobotMap;
import org.usfirst.frc3932.Settable;
import org.usfirst.frc3932.TrajectoryGenerator;
import org.usfirst.frc3932.commands.ElevatorManualControl;

import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.CANTalon.ControlMode;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
public class Elevator extends Subsystem implements Settable {


	private static final double PID_P = 3.75d;
	private static final double PID_I = 0.007d; // .2

	private static final int TICKS_PER_UPDATE = 50;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    DigitalInput bottomLimitSwitch = RobotMap.elevatorbottomLimitSwitch;
    CANTalon elevatorCANTalon = RobotMap.elevatorElevatorCANTalon;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	protected int initialPosition = 0;
	public static final double TICKS_PER_INCH = 211.92d;

	public static final double LOW_TAB_HEIGHT = 41.125d;
	public static final double HIGH_TAB_HEIGHT = 58.25d;

	/**
	 * On the ground
	 */
	private static final double START = 9.5d;

	
	
	private static final int ONE_TOTE_TICKS = 4400;
	private static final int TWO_TOTE_TICKS = 6797;
	private static final int THREE_TOTE_TICKS = 9500;
	private static final double THREE_TOTE_INCHES = 50;
	private static final int FOUR_TOTE_TICKS = 14000;
	private static final double FOUR_TOTE_INCHES = 72.625;
	
	private static final int MIN_TICKS = 50;
	private static final int MAX_TICKS = 14100;

	public TrajectoryGenerator trajectory = new TrajectoryGenerator();
	private int minTicks = MIN_TICKS;
	private int maxTicks = MAX_TICKS;
	private int ticksPerUpdate = TICKS_PER_UPDATE;
	
	private int oneToteTicks = ONE_TOTE_TICKS;
	private int twoToteTicks = TWO_TOTE_TICKS;
	
	public static enum Position {
		START(Elevator.START,1), ONE_TOTE(0, ONE_TOTE_TICKS), TWO_TOTES(0, TWO_TOTE_TICKS), 
		THREE_TOTES(Elevator.THREE_TOTE_INCHES, THREE_TOTE_TICKS), FOUR_TOTES(FOUR_TOTE_INCHES, FOUR_TOTE_TICKS);

		private double inches;
		private int ticks;

		Position(double inches, int ticks) {
			this.inches = inches;
			this.ticks = ticks;
		}
		
//		Position(double inches) {
//			this.inches = inches;
//			this.ticks = inchesToTicks(inches);
//		}

		public double getInches() {
			return inches;
		}

		public int getTicks() {
			return this.ticks;

		}
	}

	public Elevator() {
		elevatorCANTalon.changeControlMode(ControlMode.Position);
		elevatorCANTalon.setPosition(0);
		trajectory.setDestination(getMinTicks());
		trajectory.setCurrentTarget(getMinTicks());
		trajectory.setTicksPerUpdate(getTicksPerUpdate());
	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new ElevatorManualControl());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());

		elevatorCANTalon.setPID(PID_P, PID_I, 0);
		elevatorCANTalon.set(getMinTicks());
	}

	public static int inchesToTicks(double inches) {
		return (int) Math.floor((inches - Position.START.getInches()) * TICKS_PER_INCH);
	}
	

	/**
	 * Goes to a certain height.
	 * 
	 * @param pos
	 *            the height target
	 */
	public void set(int setpoint) {
		elevatorCANTalon.set(setpoint);
	}

	public double getHeight() {
		return elevatorCANTalon.get() / TICKS_PER_INCH + 9.5;
	}

	public boolean isFinished() {
		return trajectory.isFinished();
	}

	public void goToPosition(int destinationTicks) {
		trajectory.goToDestination(destinationTicks);
	}

	public void goToPosition(Position setpoint) {
		int ticks = setpoint.getTicks();
		goToPosition(ticks);
	}

	public void execute() {
		trajectory.execute(this);
	}

	public void move(double scale) {
		int newDestination = trajectory.getCurrentTarget() + (int) (scale * getTicksPerUpdate());
		if (newDestination < getMinTicks()) {
			newDestination = getMinTicks();
		}
		if (newDestination > getMaxTicks()-20) {
			newDestination = getMaxTicks()-20;
		}
		trajectory.goToDestination(newDestination);

	}

	public int getMinTicks() {
		return minTicks ;
	}
	
	public void setMinTicks(int minTicks) {
		this.minTicks = minTicks;
	}

	public int getMaxTicks() {
		return maxTicks ;
	}
	
	public void setMaxTicks(int maxTicks) {
		this.maxTicks = maxTicks;
	}

	public int getTicksPerUpdate() {
		return ticksPerUpdate ;
	}
	
	public void setTicksPerUpdate(int ticksPerUpdate) {
		this.ticksPerUpdate = ticksPerUpdate;
	}
	


}
